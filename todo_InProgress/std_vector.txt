

    [std::vector<TypDanych>] 
            - Kontener sekwencyjny STL, przechowujący tablice o zmiennej wielkości.
            - Pojemność vectora jest zarządzana automatycznie, zwiększana bądź zmniejszana w razie potrzeby.
              Vectory zwykle alokują na zapas więcej pamięci niż potrzeba.
              Dzięki temu nie muszą realokować całej pamięci przy każdym nowym elemencie.
            - Realokacje są kosztownymi operacjami pod względem wydajności. Unikać!
              Kiedy się da, ręcznie rezerwować za wczasu tyle pamięci ile potrzeba!
			- Najczęściej stosowany termin w polskich publikacjach to [Kontener], nie [Wektor].



    1. Wyświetlanie informacji o wybranym Vectorze   
         • operator []	
         • .size()
         • .capacity()		 
	
    2. Rezerwowanie Pamięci 
         • .push_back(TypDanych)
         • konstruktor
         • .resize(int)
         • .reserve(int)
         • .shrink_to_fit()
		 
    3. Iteratory
		 


 ---------------------------------------------------------- ----------------------------------------------------------
 [1. Wyświetlanie informacji o wybranym Vectorze] --------- ----------------------------------------------------------
 
    • operator []
    • .size()
    • .capacity()
     ─┬─────────────────────────────────────────────────────────────
     1│ void Show(const vector<int>& V){
     2│     /** - Funkcja którą będę w dalszej części notatek wypisywał 
     3│	          Podstawowe informacje o wybranym vectorze.
     4│         - W argumencie znajduje się referencja do jakiegoś vectora trzymającego <int>
     5│           Korzystamy z referencji aby nie tworzyć kopii danego vectora.
     6│         - Argument posiada specyfikator const, ponieważ zamierzamy 
     7│           jedynie odczytać wartości danego vectora.
     8│	    **/
     9│	
    10│	    // Operator [] zwraca REFERENCJĘ na element w określonej pozycji
    11│	    for (int i=0; i<V.size(); ++i)  // Pętla przez wszystkie elementy vectora [V].
    12│         std::cout << V[i] << " ";       // Wypisanie wartości elementu na indeksie [i].
    13│
    14│	    std::cout << "\n size: "      << V.size()          // Zwraca ilość elementów w vectorze [V].
    15│	              << "\n capacity: "  << V.capacity();     // Zwraca ilość zarezerwowanego miejsca w pamięci.
    16│ }
     :│	
    56│	// Wywołanie funkcji [Show]
    57│ vector<int> A;    // Dodawane elementy vectora będą typu <int>
    58│	
    59│ // W tym momencie vector [A] jest pusty. Nie posiada elementów, 
    60│	// i nie ma dla nich zarezerwowanego miejsca w pamięci.
    61│	Show(A);
    62│	  // size: 0
    63│	  // capacity: 0


 ---------------------------------------------------------- ----------------------------------------------------------
 [2. Rezerwowanie Pamięci] -------------------------------- ----------------------------------------------------------

      • .push_back(TypDanych)
     ─┬─────────────────────────────────────────────────────────────
     1│ vector<int> B;
     2│
     3│ // W tym momencie vector [B] jest pusty
     4│ Show(B);    // size: 0
     5│             // capacity: 0
     6│
     7│ // Dodajemy jeden nowy element do vectora [B] 
     8│ // - nowy element zostanie dodany na końcu vectora.
     9│ B.push_back(int(100));
    10│ Show(B);    // size: 1
    11│             // capacity: 1
    12│
    13│ // Dodajemy kolejny element do vectora [B] 
    14│ B.push_back(-22);
    15│ Show(B);    // size: 2
    16│             // capacity: 2
    17│
    18│ // Dodajemy jeszcze kolejny element do vectora [B] 
    29│ B.push_back(3);
    20│ Show(B);    // size: 3  !!!
    21│             // capacity: 4  !!!

    - Przed każdym WIELOKROTNYM użyciem metody [.push_back()] 
	  należy unikać kilkukrotnych realokacji vectora.
	  W kodzie wyżej, automatycznie doszło aż do trzech realokacji vectora.
	- Automatyczna [realokacja] rezerwuje dwukrotność obecnie zarezerwowanej pamięci.
	  Przykład 1
	     Jeżeli w vectorze posiadamy zarezerwowane miejsce dla [500] elementów,
	     wtedy możemy dowolnie dodawać elementy aż do pięcsetnego.
	     Jeżeli jednak w vectorze już będziemy mieli dane [500] elementów, 
	     dodanie pięćset-pierwszego [501] elementu będzie wymagało realokacji pamięci. 
	     Nowy rozmiar vectora będzie przystosowany do trzymania [500*2] = [1000] elementów. 
	
	  Przykład 2
	     Zakładając że nigdy nie alokujemy pamięci ręcznie, wtedy 
		 rezerwowane będzie tyle miejsca w pamięci, ile wynosi 
	     najmniejsza potęga dwójki w której zmieści się ilość elementów vectora. 
	     [Przykład pokazany w tabeli niżej]
		 Jest tak ponieważ:
           1*[2] = 2           4*[2] = 8           16*[2] = 32
           2*[2] = 4           8*[2] = 16          32*[2] = 64 ...
		 
	 --------------------------- --------------------------- ---------------------------
	| Ilość zarezerwowanego     | Ilość wykonanych          | Minimalna możliwa         |
	| miejsca w pamięci         | realokacji pamięci        | ilość wywołań metody      |
	| [V.capacity()]            |                           | [V.push_back(int(value))] |
	|---------------------------|---------------------------|---------------------------|
	|  0                        |  0                        |  -                        |
	|---------------------------|---------------------------|---------------------------|
	|  1                        |  1                        |  1                        |
	|---------------------------|---------------------------|---------------------------|
	|  2                        |  2                        |  2                        |
	|---------------------------|---------------------------|---------------------------|
	|  4                        |  3                        |  3                        |
	|---------------------------|---------------------------|---------------------------|
	|  8                        |  4                        |  5                        |
	|---------------------------|---------------------------|---------------------------|
	|  16                       |  5                        |  9                        |
	|---------------------------|---------------------------|---------------------------|
	|  32                       |  6                        |  17                       |
	|---------------------------|---------------------------|---------------------------|
	|  64                       |  7                        |  33                       |
	|---------------------------|---------------------------|---------------------------|
	|  128                      |  8                        |  65                       |
	|---------------------------|---------------------------|---------------------------|
	|  256                      |  9                        |  129                      |
	|---------------------------|---------------------------|---------------------------|
	|  516                      |  10                       |  257                      |
	|---------------------------|---------------------------|---------------------------|
	|  1024                     |  11                       |  517                      |
	|---------------------------|---------------------------|---------------------------|
	|  2048                     |  12                       |  1025                     |
	|---------------------------|---------------------------|---------------------------|
	|  4096                     |  13                       |  2049                     |
	|---------------------------|---------------------------|---------------------------|
	|  8192                     |  14                       |  4097                     |
	|---------------------------|---------------------------|---------------------------|
	|  16 384                   |  15                       |  8193                     |
	|---------------------------|---------------------------|---------------------------|
	|  32 768                   |  16                       |  16 385                   |
	 --------------------------- --------------------------- ---------------------------

    Oznacza to, że wypełnienie vectora o przykładowo [20 000] elementów 
    używając tylko i wyłącznie metody [.push_back()] będzie wymagało 16 realokacji. 
    16 realokacji to zdecydowanie za dużo.

	Każda realokacja jest czasochłonną operacją. Należy UNIKAĆ zbyt częstych [realokacji vectora].
	Podane w przykładzie pod tabelą [20 000] możemy zarezerwować wykonując jedynie [jedną] realokacje:

      Podejście 1
      • [konstruktor]
     ─┬─────────────────────────────────────────────────────────────
     1│ vector<int> C(20000);
     2│ Show(C);    // size: 20000
     3│             // capacity: 20000
     4│ // Nie tylko zarezerwowaliśmy miejsce w pamięci dla [20 000] elementów,
     5│ // jednocześnie utworzyliśmy te elementy, dlatego [size: 20000].
     6│ // Wszystkie te elementy są równe zero.
     7│ 
     8│ // Elementy te możemy zmodyfikować, przykładowo, operatorem[].
     9│ for (int i=0; i<C.size(); ++i)
    10│     C[i] = i;
    11│ 
    12│ // Inna wersja konstruktora pozwala nam na inicjalizację 
    13│ // wszystkich elementów inną wartością niż [zero].  
    14│ vector<int> CC(20000, -6);
    15│ 
    16│ // W tym momencie wszystkie utworzone elementy 
    17│ // vectora [CC] posiadają wartość [-6]:
    18│ for (int i=0; i<CC.size(); ++i)
    19│     std::cout << " " << CC[i];


      Podejście 2
      • .resize(int)
     ─┬─────────────────────────────────────────────────────────────
     1│ vector<int> D;
     2│ // _____________
     3│ // Scenariusz 1:   Vector D jest pusty, [size=0], [capacity=0].
     4│ D.resize(20000);
     5│ Show(D);    // size: 20000
     6│             // capacity: 20000
     7│ // Ponownie, utworzyliśmy [20 000] elementów o wartości równej zero.
     8│ // Powstałe elementy możemy zmodyfikować tak samo jak w podejściu pierwszym z konstruktorem.
     9│ 
    10│ // Te [20 000] elementów już teraz istnieje.
    11│ // Oznacza to że użycie metody [.push_back(typDanych)] w tym 
    12│ // momencie spowoduje utworzenie [20001] elementu, co spowoduje
    13│ // ponowną realokacje do rozmiaru [20 000 * 2], czyli [40 000].
    14│
    15│ // _____________
    16│ // Scenariusz 2:   Vector D jest nie pusty, dodajemy do niego więcej miejsca
    17│ D.resize(55555);
    18│ /*  - Nie zostaną zmodyfikowane już istniejące elementy.
    19│     - Zostanie wykonana potrzebna realokacja.
    20│       Wcześniejsza ilość zarezerwowanego miejsca to było [20 000]
    21│       Dwukrotność poprzednio zarezerwowanego miejsca wynosi [40 000]
    22│       Jeżeli chcemy zarezerwować więcej miejsca niż dana dwukrotność, 
    23│       wtedy zarezerwuje nam dokładnie tyle miejsca, o ile poprosiliśmy. Czyli [55 555].
    24│       Jeżeli jednak chcemy zarezerwować mniej niż [40 000], wtedy i tak zarezerwuje nam [40 000].
    25│       W ten sposób vektor minimalizuje ilość automatycznych realokacji w przyszłości.
    26│     - Nowe miejsce zostanie wypełnione nowymi elementami o wartości zero.  */
    27│
    28│ // _____________
    29│ // Scenariusz 3:   Vector D jest nie pusty, Zmniejszamy w nim ilość miejsca
    30│ D.resize(100);
    31│ /*  - Nie zostaną zmodyfikowane już istniejące, mieszczące się w przedziale elementy.
    32│     - Elementy nie mieszczące się w przedziale zostaną bez powrotnie skasowane.
    33│     - Nie zostanie wykonana realokacja pamięci.
    34│       Oznacza to że w vectorze będzie [100] elementów - [size = 100]
    35│       Jednocześnie będzie zarezerwowana ostatnia ilość pamięci - [capacity = 55 555]  */


      Podejście 3
      • .reserve(int)
     ─┬─────────────────────────────────────────────────────────────
     1│ vector<int> E;
     2│
     3│ // Zaczynamy, Vector E jest pusty, [size=0], [capacity=0].
     4│ E.reserve(20000);
     5│ Show(E);    // size: 0
     6│             // capacity: 20000
     7│ // Metoda [.reserve(int)] jedynie rezerwuje podaną ilość miejsca,
     8│ // nie tworzy przy tym nowych elementów.
     9│
    10│ // Dlatego w tym momencie możemy utworzyć nowe elementy metodą [.push_back(typDanych)]
    11│ for (int i=0; i<E.capacity(); ++i)   // Pamiętaj że [size()] jest równe [zero].
    12│     E.push_back(i);
    13│
    14│ Show(E);    // size: 20000
    15│             // capacity: 20000
    16│ 
    17│ // __________________________________________________________
    18│ // Argument metody [.reserve(int)] określa minimalną ilość elementów w vectorze.
    19│ // Nigdy nie ma problemu z zwiększeniem tej ilości.
    20│ E.reserve(20111);
    21│ 
    22│ // Zostanie wykonana realokacja do rozmiaru dokładnie [20 111] elementów. 
    23│ // Zostaje tutaj pominięta zasada dwukrotności, czyli NIE zostanie 
    24│ // zarezerwowane miejsce dla [40 000] elementów.
    25│ 
    26│ // __________________________________________________________
    27│ // Nie można zarezerwować mniej miejsca niż obecnie jest zarezerwowane w vectorze.
    28│ // Obecny stan naszego vectora to:
    29│ Show(E);    // size: 20000
    30│             // capacity: 20111
    31│ 
    32│ // Podanie mniejszej wartości NIE zmodyfikuje
    33│ // ilości obiektów, ani ilości zarezerwowanego miejsca. 
    34│ 
    35│ E.reserve(50);
    36│ Show(E);    // size: 20000
    37│             // capacity: 20111


      Zwalnianie NADMIARU zarezerwowanej pamięci
      • .shrink_to_fit()
     ─┬─────────────────────────────────────────────────────────────
     1│ vector<int> F(112,1);
     2│ F.reserve(200);
     3│ Show(F);    // size: 112
     4│             // capacity: 200
     5│ 
     6│ // Metoda [.shrink_to_fit()] realokuje pamięć do ilości jej elementów.
     7│ // Nie usuwa elementów. Wartość [capacity] staje się równa wartości [size].
     8│ 
     9│ F.shrink_to_fit();
    10│ Show(F);    // size: 112
    11│             // capacity: 112






 by: Kacu
|                  $$NDDDDDDNDDNDDDN8=
|               ZZNNDDNNDDDDDDNDDDDNNDND
|             $Z8NDDNDNNDDNDDNMDDDDDNDNDN
|           $$DNDDDDNNDDDNDNNDDDNNNDDDNN8?~
|          $NDNDDDDNNDDDD:''''''''''''''''''
|         8DDNDDDDDNO++:''''''''''''''''''''
|         8NNDDDN++=++O''''''''''''''''''''''
|        ZNNNM+++++++?+:'''''''''''''''''''',
|        $ND=+++++++++?'''',,,,,,:,'''''+NNDN
|        $N+++++++++++Z''IMDNNNDND'''''NDD,,,
|        ?,,,:7+++?::''''''''''''''''''''''''
|        ,,,:,7+++?,'''''''''''''''''''''''''
|        :,,,,~7+I,''''''''''''''''''''''''''
|          ,,,,$:''''''''''''''''''''''''''''
|           ,,:+:''''''''''''''''''''''''''''
|             ~Z?''''''''''''''''''''''''''''
|              +'''''''''''''''''''''''''''''
|              '$'''''''''''''''''''''''''''
|              '''Z'''''''''''''''''''''''''
|              '''''~''''''''''''''''''''''
|              '''''''=''''''''''''''?DI,''
|              '''''''''?'''''''''''''''''
|              '''''''''''=?=''''''''$DDI~
|               ''''''''''''''=+''DNDDNDN$
|                '''''''''''''''=:?8$ZZZ$
|                 '''''''''''''''
|                  ''''''''''''''
|                    '''''''''
|                     '''''

